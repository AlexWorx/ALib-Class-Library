// #################################################################################################
//  Documentation - ALib C++ Library
//
//  Copyright 2013-2023 A-Worx GmbH, Germany
//  Published under 'Boost Software License' (a free software license, see LICENSE.txt)
// #################################################################################################

/**
\page alib_manual    ALib Programmer's Manual

\tableofcontents

\I{################################################################################################}
# 1. Introduction # {#alib_manual_intro}

Welcome the Programmer's Manual of the  <b>%ALib C++ Class Library</b>!

This manual explains the structure and concepts of the library and it's general use.
The library is divided into so called <b>"ALib Modules"</b> which comprise the actual library
functionality. Please note, that for most of these modules
\ref alib_manual_modules_overview "dedicated Programmer's Manuals" exists,
which solely address a module's field of application.

The module's entities reside in sub-namespaces of the libraries root namespace \"ref aworx::lib\",
which consequently is rather quite empty.
The majority of the remaining code in that namespace is related to organize the
modules.

It becomes quite obvious, that before talking any further about this library, all about
<b>%ALib Modules</b> has to be explained!



\I{################################################################################################}
# 2. ALib Modules # {#alib_manual_modules}

Being a "general purpose" C++ library, quite different areas of programming are addressed by \alib.
This is why the library code and documentation is organized into different so called "modules".

\note
  The term \e module relates to the planned future C++ language feature with the same name.
  As of today C++ modularization is not technically used with \alib, yet.
  Experimental support for implementing \alibmods_nl as C++ modules is planned for
  \checkpromise{one of the next release, probably in 2024}.

The rationals for organizing the library in modules are:

1. Design Principle of Orthogonality<br>
   The modularization of the library is first of all a design principle, forcing library
   features to "fall into place" and make types and methods "orthogonal". (Orthogonal software
   can be considered as the opposite of "spaghetti code".)

2. Comprehensible<br>
   Users of the library are able to grasp the overall feature set much faster due to the
   modularization. As an example, the
   \ref alib_expressions_intro_procon "features of module ALib Expressions", is currently more
   than 25 bullet points. A user not interested in run-time expression evaluation, will
   not be bothered with that. The module has an own namespace, separated reference documentation
   and Programmer's Manual.

3. Well Defined Library Bootstrapping<br>
   As explained in a later chapter, bootstrapping a software process written in C++ needs to
   obey to some certain rules which the programming language itself does not provide support
   for. \alibmods_nl tremendously helps organizing the library bootstrap process.


4. Minimum Footprint<br>
   Modules can be compiled and used separately from others, as long as there is no dependency
   between modules.
   When using \https{CMake,cmake.org/} to build the library, all module-dependencies are
   automatically resolved: If a using application just needs a single module, that module is
   all that has to be specified with CMake. The provided scripts select the dependent modules and
   corresponding source files automatically.

5. Build-Speed<br>
   The ability to just partly compile (and use) \alib also increases build speed. Not only that
   of the library itself, but also that of the user code (due to the selective header inclusion).


\I{################################################################################################}
## 2.1 Overview Of Modules ## {#alib_manual_modules_overview}

The following table lists all \alibmods_nl in alphabetical order.

Name <br>(Programmer's Manual)     |Namespace <br>(Reference Documentation)    | Description |
-------------------------------------------|-------------------------------|-------------------------------
\ref alib_mod_alox          "ALox"         | \ref aworx::lib::lox          |A very unique and powerful approach to implement a software's debug and release logging facilities.
\ref alib_mod_bitbuffer     "BitBuffer"    | \ref aworx::lib::bitbuffer    |Provides types to read and write data into a stream of bits in a platform independent manner. Furthermore different compression algorithms are given.
\ref alib_mod_boxing        "Boxing"       | \ref aworx::lib::boxing       |Implements <b>"auto-boxing"</b> for C++, known from higher level programming languages. Transparently wraps C++ values of arbitrary type together with run-time type information into very lightweight objects. In other words, this library provides <em>"type-safe void pointers which support virtual function calls"</em>, provides type-safe a variadic argument paradigm and much more.
\ref alib_mod_characters    "Characters"   | \ref aworx::lib::characters   |Mitigates C++ character type, character pointer and character array hell.
\ref alib_mod_cli           "CLI"          | \ref aworx::lib::cli          |Implements parsing and partly the processing of command line arguments (CLI stands for "command line interface"). In case of pure CLI software, provides tools for formatted and localized help and result output.
\ref alib_mod_config        "Configuration"| \ref aworx::lib::config       |Transparently encapsulates access to configuration or other input data coming from various sources, like command line parameters, environment variables, INI-files, 3rd-party configuration databases, etc. Support for persistent write-back of such data is given.
\ref alib_mod_enums         "Enums"        | \ref aworx::lib::enums        |Extensions for otherwise limited C++ enum types.
\ref alib_mod_expressions   "Expressions"  | \ref aworx::lib::expressions  |Expression parser, compiler and a virtual machine for evaluation of compiled expressions. Excels in respect to speed and flexibility and is very easy to adopt in own projects.
\ref alib_mod_monomem        "Monomem"     | \ref aworx::lib::monomem      |Today, this module only consists of one simple class that features monotonic allocation of objects. In combination with \alib_strings (optional dependency), monotonic allocation of string data is supported as well.
\ref alib_mod_results       "Results"      | \ref aworx::lib::results      |Provides the standard \alib throwable type \alib{results,Exception} supporting "inner exceptions" and resourced exception details. Furthermore provides \alib{results,Report,ALib Reports}, which is a simple reporting system. (Not very good, currently used only with debug builds for assertions, and expected to be changed in the future!).
\ref alib_mod_resources     "Resources"    | \ref aworx::lib::resources    |String-based resource management. Usually, other modules that depend on (use) this module are named <em>"full module"</em> and dispose about a singleton that derives from library class \alib{Module}, which holds a pointer to the resources type found here.<br> This module in addition provides some "resourced types", and is especially helpful to extend the concept of \ref alib_enums_records "ALib Enum Records".
\ref alib_mod_singletons    "Singletons"   | \ref aworx::lib::singletons   |Implements the singleton paradigm that overcomes the Windows OS DLL boundaries (caused by Window DLL's local data segments), while under other operating systems chooses a faster, straight-forward implementation.
\ref alib_mod_text          "Text"         | \ref aworx::lib::text |Implements Python- and JAVA compatible string formatters and other string formatting tools.
\ref alib_mod_strings       "Strings"      | \ref aworx::lib::strings      |With a least intrusive design offers compatible, lightweight, secure, efficient, complete and convenient C++ string classes.
                             System        | \ref aworx::lib::system       |Types related to the operating system and hardware environment.
\ref alib_mod_threads       "Threads"      | \ref aworx::lib::threads      |Thread locking, threads and runables.
\ref alib_mod_time          "Time"         | \ref aworx::lib::time         |A few useful tools for otherwise limited C++ scoped and non-scoped enum types.

\I{################################################################################################}
## 2.2 Module Dependencies ## {#alib_manual_modules_dependencies}

\I{################################################################################################}
### 2.2.1 Mandatory Dependencies ### {#alib_manual_modules_dependencies_mandatory}

Modules of \alib have dependencies. For example, module \alib_strings does not compile without
the availability of module \alib_characters.

There is only one case where such dependency is circular. This concerns modules
\alib_results and \alib_text. Both modules rely on the existence of each other.


The following diagram shows the mandatory dependencies between the modules:
\anchor alib_manual_modules_dependency_graph

\I{Comment: Sometimes, doxygen does not show the graph below. Then an empty graph helps. Dont know what this is!}

  \dot
  digraph forSomeReasonsDoxygenSometimesNeedsAnEmptyGraphHere_Strange {}
  \enddot

\dot
digraph ModuleDependencies
{
    compound=true;
    fontsize="10";
    fontname="Open Sans";

    node [shape=plaintext, fontsize="10", fontname="Open Sans"]


    //--- Full Modules ---
    ALox           [label= ALox            shape= "component" style="bold" color="midnightblue"  URL="\ref alib_mod_alox"         ];
    Expressions    [label= Expressions     shape= "component" style="bold" color="midnightblue"  URL="\ref alib_mod_expressions"  ];
    Configuration  [label= Configuration   shape= "component" style="bold" color="midnightblue"  URL="\ref alib_mod_config"       ];
    CLI            [label= CLI             shape= "component" style="bold" color="midnightblue"  URL="\ref alib_mod_cli"          ];
    System         [label= System          shape= "component" style="bold" color="midnightblue"  URL="namespaceaworx_1_1lib_1_1system.html"];
    Results        [label= Results         shape= "component" style="bold" color="midnightblue"  URL="\ref alib_mod_results"     ];
    Text           [label= Text            shape= "component" style="bold" color="midnightblue"  URL="\ref alib_mod_text" ];

    subgraph sameRank1   {  rank="same";  CLI; Expressions; ALox;     }
    subgraph clusterMod
    {
        rank="same";  Results; Text;
        color="midnightblue"

        //label= "Full Modules"
        subgraph sameRankMod {   rank="same";  Results; Text;    }

    }

    //--- dependencies full -> full
    ALox            ->  Configuration   [ color="midnightblue" ];
    Expressions     ->  Text            [ color="midnightblue" lhead="clusterMod" ];
    Configuration   ->  System          [ color="midnightblue" ];
    CLI             ->  Text            [ color="midnightblue" lhead="clusterMod" ];
    System          ->  Text            [ color="midnightblue" lhead="clusterMod" ];
    Results         ->  Text            [ color="midnightblue" ];
    Text            ->  Results         [ color="midnightblue" ];

    //--- Micro Modules ---
    Resources      [label= Resources       shape= "box"        color="cornflowerblue"   URL="\ref alib_mod_resources"    ];
    Threads        [label= Threads         shape= "component"  color="cornflowerblue"   URL="\ref alib_mod_threads"      ];
    Boxing         [label= Boxing          shape= "component"  color="cornflowerblue"   URL="\ref alib_mod_boxing"       ];

    Strings        [label= Strings         shape= "box"        color="cornflowerblue"   URL="\ref alib_mod_strings"      ];
    Time           [label= Time            shape= "component"  color="cornflowerblue"   URL="\ref alib_mod_time"         ];
    Characters     [label= Characters      shape= "box"        color="cornflowerblue"   URL="\ref alib_mod_characters"   ];
    Enums          [label= Enums           shape= "box"        color="cornflowerblue"   URL="namespaceaworx_1_1lib_1_1enums.html"     ];
    Singletons     [label= Singletons      shape= "box"        color="cornflowerblue"   URL="\ref alib_mod_singletons"   ];
    Monomem        [label= Monomem         shape= "box"        color="cornflowerblue"   URL="\ref alib_mod_monomem"      ];
    BitBuffer      [label= BitBuffer       shape= "box"        color="cornflowerblue"   URL="\ref alib_mod_bitbuffer"      ];

    subgraph sameRankA   {  rank="same";  Resources; Threads;                         }
    subgraph sameRankB   {  rank="same";  Boxing;    Strings;   Enums                 }
    subgraph sameRankC   {  rank="same";  Time;     Characters; Monomem; Singletons;  }

    //--- dependencies headless -> headless
    Resources       -> Strings       [ color="cornflowerblue"  ];
    Resources       -> Monomem       [ color="cornflowerblue"  ];
    Resources       -> Singletons    [ color="cornflowerblue"  ];
    Threads         -> Strings       [ color="cornflowerblue"  ];
    Strings         -> Characters    [ color="cornflowerblue"  ];
    Boxing          -> Characters    [ color="cornflowerblue"  ];
    Boxing          -> Singletons    [ color="cornflowerblue"  ];
    Enums           -> Singletons    [ color="cornflowerblue"  ];
    BitBuffer       -> Monomem       [ color="cornflowerblue"  ];
    BitBuffer       -> Enums         [ color="cornflowerblue"  ];
    Enums           -> Strings       [ color="cornflowerblue"  ];

    //--- dependencies full -> headless
    System          -> Time          [ color="cornflowerblue"  ];
    Text            -> Resources     [ color="cornflowerblue"  ltail="clusterMod" ];
    Text            -> Boxing        [ color="cornflowerblue"  ltail="clusterMod" ];
    Results         -> Enums         [ color="cornflowerblue"  ltail="clusterMod" ];
}
\enddot

\note
  - The dark blue modules contain a singleton derived
    from class \alib{Module} and can be considered <b>"full modules"</b>.<br>
    The light blue modules do not dispose of a module-class and are referred to as
    <b>"micro modules"</b>.
  - The two small rectangles on the left side of some of the module boxes indicate that a
    module has initialization and termination functions that needs to be invoked with bootstrapping
    a process, respectively terminating it. As it can be seen (and will be discussed later)
    this is true for all <em>"full modules"</em>, but also for some of the <em>"micro modules"</em>

\note
  The exact meaning of these differences will be discussed later in this manual.



\I{################################################################################################}
### 2.2.2 Optional Relationships ### {#alib_manual_modules_dependencies_supporting}
Besides the mandatory dependencies shown in the graph above, also optional relations between the
modules exist. Those could be phrased as <em>\"Module \b A makes use of module \b B if \b B is
available\"</em>.

These relationships are documented with each module's Programmer's Manual.
Furthermore, within the reference documentation, you will find sentences like
<em>\"This feature is available only if module <b>ALib XYZ</b> is included in the \alibdist_nl.\"</em>

The following diagram shows the optional dependencies:

\dot
digraph OptionalModuleDependencies
{
    compound=true;
    fontsize="10";
    fontname="Open Sans";

    node [shape=plaintext, fontsize="10", fontname="Open Sans"]


    //--- Full Modules ---
    ALox           [label= ALox            shape= "component" style="bold" color="midnightblue"  URL="\ref alib_mod_alox"         ];
    Expressions    [label= Expressions     shape= "component" style="bold" color="midnightblue"  URL="\ref alib_mod_expressions"  ];
    Configuration  [label= Configuration   shape= "component" style="bold" color="midnightblue"  URL="\ref alib_mod_config"       ];
    CLI            [label= CLI             shape= "component" style="bold" color="midnightblue"  URL="\ref alib_mod_cli"          ];
    System         [label= System          shape= "component" style="bold" color="midnightblue"  URL="namespaceaworx_1_1lib_1_1system.html"];
    Results        [label= Results         shape= "component" style="bold" color="midnightblue"  URL="\ref alib_mod_results"     ];
    Text           [label= Text            shape= "component" style="bold" color="midnightblue"  URL="\ref alib_mod_text" ];

    subgraph sameRank1   {  rank="same";  CLI; Expressions; ALox;     }
    subgraph sameRank1   {  rank="same";  Configuration; System;      }
    subgraph clusterMod
    {
        rank="same";  Results; Text;
        color="midnightblue"

        //label= "Full Modules"
        subgraph sameRankMod {   rank="same";  Results; Text;    }

    }

    //--- optional dependencies full -> full
    Expressions     ->  System          [ color="midnightblue" ];
    Expressions     ->  Configuration   [ color="midnightblue" ];

    //--- Micro Modules ---
    Resources      [label= Resources       shape= "box"        color="cornflowerblue"   URL="\ref alib_mod_resources"    ];
    Threads        [label= Threads         shape= "component"  color="cornflowerblue"   URL="\ref alib_mod_threads"      ];
    Boxing         [label= Boxing          shape= "component"  color="cornflowerblue"   URL="\ref alib_mod_boxing"       ];

    Strings        [label= Strings         shape= "box"        color="cornflowerblue"   URL="\ref alib_mod_strings"      ];
    Time           [label= Time            shape= "component"  color="cornflowerblue"   URL="\ref alib_mod_time"         ];
    Characters     [label= Characters      shape= "box"        color="cornflowerblue"   URL="\ref alib_mod_characters"   ];
    Enums          [label= Enums           shape= "box"        color="cornflowerblue"   URL="namespaceaworx_1_1lib_1_1enums.html"     ];
    Singletons     [label= Singletons      shape= "box"        color="cornflowerblue"   URL="\ref alib_mod_singletons"   ];
    Monomem        [label= Monomem         shape= "box"        color="cornflowerblue"   URL="\ref alib_mod_monomem"      ];

    subgraph sameRankA   {  rank="same";  Resources; Threads;     }
    subgraph sameRankB   {  rank="same";  Boxing; Strings;        }
    subgraph sameRankC   {  rank="same";  Time; Characters; Monomem; Singletons; Enums;     }

    //--- optional dependencies headless -> headless
    Resources       -> Threads       [ color="cornflowerblue"  ];
    Resources       -> Configuration [ color="cornflowerblue"  ];
    Resources       -> Results       [ color="cornflowerblue"  ];

    Threads         -> Enums         [ color="cornflowerblue"  ];
    Threads         -> Monomem        [ color="cornflowerblue"  ];
    Threads         -> Time          [ color="cornflowerblue"  ];

    Strings         -> Threads       [ color="cornflowerblue"  ];
    Strings         -> Enums         [ color="cornflowerblue"  ];
    Strings         -> Resources     [ color="cornflowerblue"  ];

    Boxing          -> Threads       [ color="cornflowerblue"  ];
    Boxing          -> Strings       [ color="cornflowerblue"  ];
    Boxing          -> Text          [ color="cornflowerblue"  ];
    Boxing          -> Monomem       [ color="cornflowerblue"  ];

    Enums           -> Resources     [ color="cornflowerblue"  ];
    Enums           -> Strings       [ color="cornflowerblue"  ];

    Monomem         -> Threads       [ color="cornflowerblue"  ];
    Monomem         -> Strings       [ color="cornflowerblue"  ];

    Singletons      -> Threads       [ color="cornflowerblue"  ];
    Singletons      -> Monomem       [ color="cornflowerblue"  ];
    Singletons      -> Strings       [ color="cornflowerblue"  ];


    //--- optional dependencies full -> headless
    ALox            -> Threads       [ color="cornflowerblue"  ];
    Configuration   -> Threads       [ color="cornflowerblue"  ];
    System          -> Threads       [ color="cornflowerblue"  ];
    Results         -> Threads       [ color="cornflowerblue"  ];
    Expressions     -> Time          [ color="cornflowerblue"  ];
}
\enddot


\I{################################################################################################}
## 2.3 Impacts of Module Dependencies ## {#alib_manual_modules_impact}
The fact of having (selectable) modules that are connected through a set of dependencies, has to
be taken into account in different ways.

\I{################################################################################################}
### 2.3.1 Impact on Source Selection / Compilation ### {#alib_manual_modules_impact_sources}

The selection of \alib library source code to compile (either to a dedicated library file or directly
into a custom software unit) depends on the permutation of selected modules.
Now, as the modules have dependencies, all sources of all dependent modules have to be
(recursively) selected.

\alib comes with a set of \e CMake scripts that perform such selection. Even if \e CMake is not used
for the daily build process, the scripts may be used once to select the source and header files
needed to feed them into the build system in place.

All details about the build process are given in section \ref alib_manual_build "4. Building The Library".

\I{################################################################################################}
### 2.3.2 Impact on Header File Inclusion and Code Selection ### {#alib_manual_modules_impact_codeselection}

ALib header files are designed to be always includable, without the precondition to include other
files before. For example, to work with type \alib{strings,TAString,AString}, it is enough
to state

        #include "alib/strings/astring.hpp"

at the top of the compilation unit in question. Through the recursive header inclusion, the very
first header that is processed is always:

&nbsp;&nbsp;&nbsp;&nbsp;\alibheader{lib/modules.hpp}

This header analyzes the given set of \ref GrpALibPreproSymbols "compiler symbols" which
define the modules included in a distribution. These symbols are:

- \ref ALIB_ALOX
- \ref ALIB_BOXING
- ...
- ...
- \ref ALIB_TIME

Each symbol that is not given will be defined as either \c 0 or \c 1, by resolving all dependencies
of those symbols given.

\I{################################################################################################}
### 2.3.3 Impact on Bootstrapping ### {#alib_manual_modules_impact_bootstrapping}

Selected modules have to be initialized in the right order. "Most independent" have to be
initialized first, dependent modules afterwards.
All information about bootstrapping the library is provided later in this manual, namely
in chapter \ref alib_manual_bootstrapping "3. Bootstrapping ALib".

\I{################################################################################################}
### 2.3.4 Single Threaded Library Compilation ### {#alib_manual_modules_impact_singlethreaded}
Excluding module \alib_threads from an \alibdist_nl has the special effect of
compiling \alib for single-threaded execution. Due to the fact that \alib uses class
\alib{threads,ThreadLock} and sibling types from this module for all its <em>"mutex locks"</em>,
leaving out this module removes just all concurrency protection from <b>every remaining module</b>!

The advantage of this approach lies of course in performance and code size of single-threaded
compilations, because setting a mutex is a redundant action there. It is important to understand that
module \alib_threads_nl is <b>mandatory</b> if concurrent access to library functions
is performed.

In debug-compilations of the library, if module \alib_threads_nl is omitted, single-threaded
use is therefore asserted: An \alib assertion is raised when multi-threading is detected.

To detect multi-threading in debug-code, the underlying threading library (e.g. "pthreads" on
GNU/Linux) has to be provided with the build. For this reason, the default <b>CMake</b>-script,
which is described in later sections, does \b not depend on the inclusion of module
\alib_threads_nl, but just \b always searches the target system's thread library.
If found, symbol \ref ALIB_EXT_LIB_THREADS_AVAILABLE is passed to the C++ compiler.

The way to prevent searching and adding a thread library is by setting special <b>CMake</b> cached
variable \ref alib_manual_build_cmake_3 "LIB_CMAKE_SKIP_THREAD_LIB_SEARCH" to \c true.

In general it could be said:
\attention
   It is highly recommended to include module \alib_threads in an \alibdist_nl.

...unless a user knows exactly what she is doing!



\I{################################################################################################}
## 2.4 File Sets ## {#alib_manual_modules_filesets}
There are a few source files and corresponding types in \alib that are not associated with a module,
but rather belong to the library in general.
The source files are located in sub-folder <c>alib/lib</c> and the corresponding C++ types are
collected in the library's root namespace #aworx::lib.

These files are organized in "file sets", which again have a dependency relation with
the modules. This means, that files belonging to a set have to be included in the build process
if one or more of the selected module depend on the corresponding file-set.

The same that was explained in the previous section about modules is true for the file-sets:
The \e CMake scripts as well as header file \alibheader{lib/modules.hpp} are identifying the necessary
file-sets from the list of modules included.

The following  \ref GrpALibPreproSymbols represent the file-sets
defined and are set to either \c 0 or \c 1:

- \ref ALIB_FILESET_OWNER
- \ref ALIB_FILESET_COMMON_ENUMS
- \ref ALIB_FILESET_MODULES
- \ref ALIB_FILESET_LISTS
- \ref ALIB_FILESET_PLUGINS

These symbols must not be passed to the compiler as an option, but are internally deduced from
the set of included modules.

While no further documentation is given, if required, the following information can be collected
from the sources:
- Dependencies:<br>
  Header file \alibheader{lib/modules.hpp} as well as \e CMake script <c>ALibModules.cmake</c>
  contain the dependency relationship of modules and file-sets.
- Sources of Modules and File-Sets:<br>
  The source files that belong to each file-set are defined with \e CMake script
  <c>ALibSources.cmake</c>.

An important file-set is <c>"Modules"</c>. This incorporates library types \alib{Module} and
\alib{ALibDistribution}. It is included in the moment any of the
\ref alib_manual_modules_dependency_graph "full modules" is included in the \alibdist.

\I{################################################################################################}
## 2.5  The Term "ALib Distribution" ## {#alib_manual_modules_dist}
Within this manual, the distinct manuals of \alibmods_nl and within the reference documentation,
the term "ALib Distribution" is frequently used. The term addresses the permutation of modules
that have been selected from the overall set of modules, at the time of compiling the library.
It might be in a user's interest to reduce \alib to a subset of its functionality and this way
speed up compilation and decrease library footprint.

The omission of single modules might have "side effects" on other modules, in that respect that
while they are still compilable, certain features might be dropped. If this is the case,
such dropping is always documented with the feature (function, type, method, member, etc.).

As a sample, \alib_expressions can be compiled with the absence of module \alib_config,
however in this case, functionality for loading and automatically compiling nested expression
strings defined in INI-files, command-line arguments, etc. is dropped.

\I{################################################################################################}
## 2.6  Special Treatment For Modules ALox And Threads ## {#alib_manual_modules_special_alox}
A special treatment is granted to module \alib_alox, by having header file \alibheader{alox.hpp}
always included in any \alibdist. For this reason, the file is placed outside of
directory \alibsrcdir{alox}, and instead right inside the source's root folder \alibsrcdir.

This allows a user to place \alox log statements in a compilation unit without the need of testing
preprocessor symbol \ref ALIB_ALOX or the use of macros \ref ALIB_IF_ALOX and \ref ALIB_IFN_ALOX,
in the case that her sources should be ready to compile likewise in an \alibdist_nl that does
not include \alox.

Similar to this, macros \ref ALIB_LOCK and \ref ALIB_LOCK_WITH remain available in the absence
of module \alib_threads, as already discussed in previous section
\ref alib_manual_modules_impact_singlethreaded.

\I{################################################################################################}
\I{##########  3.  Bootstrapping ALib                                                              }
\I{################################################################################################}
# 3. Bootstrapping And Shutting Down ALib # {#alib_manual_bootstrapping}

The term "bootstrapping" means the one-time initialization of the library that is to be performed
in an early stage of a software process.
The counterpart of bootstrapping is "shutting down" the library.

Standard bootstrapping and shutdown of \alib is performed by invoking methods
\alib{Module::Bootstrap}, respectively \alib{Module::Shutdown} on the singleton
instance \ref aworx::ALIB of class \alib{ALibDistribution}.
Such invocation usually is performed as one of the first and last actions in method \c main.
In source code, this simply looks like this:

        #include "alib/distribution.hpp"

        int main( int argc, const char **argv )
        {
            aworx::ALIB.Bootstrap(argc, argv);
            ...
            ...
            ...
            aworx::ALIB.Shutdown();

            return 0;
        }


The following chapters explain the details behind these invocations, provide recipes to customize
certain aspects of the process and explain how  - optionally - the provided mechanics can be
leveraged for the bootstrapping and shutdown of custom code entities likewise.

\I{################################################################################################}
## 3.1 Weak Support For Bootstrapping In C++ ## {#alib_manual_bootstrapping_cpp}

The following circumstances increase the complexity of bootstrapping:

<b>1. The C++ Language:</b><br>

\par
The C++ language specification misses sophisticated support for bootstrapping a software process.
Basically, the only two things that are guaranteed by the language are:
- Global and static data will be initialized.
- After this is done, a method called <c>main()</c> is invoked.

\par
This specification especially misses an order of the initialization of global or static data.
Note that data initialization might execute arbitrary constructor code, hence also the order of
such custom code execution is random.

<b>2. Resources And Configuration Data:</b><br>

\par
Bootstrapping becomes even more complicated with the use of
1. Resources (for example externally managed string resources) and
2. Configuration data (e.g. configuration files, command line parameters, etc.).

\par
With \alib, such custom data sources might furthermore be provided by plug-ins, which means the code
entity that performs the provision of resources and configuration data needs to be initialized
before the data is used.

<b>3. Module Dependencies:</b><br>

\par
The dependencies between the modules have to be respected during initializations.
As mentioned already, dependent modules have to be initialized first.

<b>4. Multi-Threaded Access:</b><br>

\par
Multi-Threaded software has to take preparations to avoid undefined behavior due to thread-racing
conditions while accessing "shared resources", which is often simply shared memory.
Such preparation involves a performance penalty.
In the case that all modifications of the memory that is to be protected can be aggregated to
a one-time initialization action during bootstrap, such precaution could be omitted if
bootstrapping guaranteed a period of single threaded access.


\I{################################################################################################}
## 3.2 Class Module ## {#alib_manual_bootstrapping_class_module}

\alib supports the management of (string) resources with module \alib_resources. Looking
at the \ref alib_manual_modules_dependency_graph "module dependency graph" above, it can be
observed that each module that is directly or indirectly dependent on \alib_resources_nl
(which means the module is using resources) is colored in dark blue and was named a "full module".

The reason for this is, that as soon as a module is either using resources or configuration data, a
singleton type derived from class \alib{Module} will be added to the module's codebase.
For example, the singleton type of module \alib_expressions is class \alib{expressions,Expressions}
and the one of module \alib_cli is class \alib{cli,Cli}.<br>
As modules may (and usually do) share resources and configuration data, the class implements data
members \alib{resources,ResourcePool} and \alib{config,Configuration} as pointers.

\I{################################################################################################}
### 3.2.1 Singletons ### {#alib_manual_bootstrapping_class_module_singletons}

Class \b %Module is one of the few types in \alib that is not part of a specific module,
and as such it is placed in the root namespace of the library, #aworx::lib.<br>

The different types derived from class \b Module are "strict singleton" types, which means
that only one object must be created. These singleton objects are collected in namespace
#aworx::lib with global instances:
- aworx::lib::ALOX
- aworx::lib::CLI
- aworx::lib::CONFIG
- aworx::lib::EXPRESSIONS
- aworx::lib::RESULTS
- aworx::lib::TEXT
- aworx::lib::SYSTEM

\note
  As explained previously,
  \ref alib_manual_modules_dependencies_mandatory "\"micro modules\" available in the library",
  do not use resources or configuration data and hence no module singleton exists.

\note
  Further note, that the derived modules do not implement the typical "singleton design pattern"
  proposed by common C++ language guidelines, which for example suggest to make the constructor
  \c private and provide a getter method that returns a local static instance.<br>
  Instead the constructor raises a run-time exception in debug-compilations, if an object was
  created that is not the singleton found in namespace #aworx::lib.<br>
  To take this approach is purely a design decision, With it, all module instances are
  nicely "sitting next to each other" in namespace #aworx::lib.

Special module class \alib{ALibDistribution}, that is discussed later, is residing in namespace
\b aworx and is given with global instance

- aworx::ALIB


\I{################################################################################################}
### 3.2.2 Bootstrapping And Shutdown Interface ### {#alib_manual_bootstrapping_class_module_bootstrapping}

For bootstrapping and shutdown, derived types need to implement two protected, \b abstract methods:
- \alib{Module::bootstrap} and
- \alib{Module::shutdown}.

Both methods are invoked more than once: Bootstrapping is done in <b>three phases</b>, defined by
enumeration \alib{Module::BootstrapPhases} and shutdown is done in <b>two phases</b>, defined by
enumeration \alib{Module::ShutdownPhases}.
The implementations of the methods need to switch upon the given levels and perform different tasks.

Each phase will be finished for all modules, before a subsequent phase is initiated.
The loop over the phases and its inner loop over the list of modules is implemented with interface
method \alib{Module::Bootstrap}, respectively \alib{Module::Shutdown}.
\note Mind the capital ’I' and 'S'' of both methods, in contrast to lower case names of previously
      mentioned protected, abstract virtual methods \b bootstrap and \b shutdown.

\I{################################################################################################}
#### 3.2.2.1 Bootstrap Phases #### {#alib_manual_bootstrapping_class_module_bootstrapping_bs}

With \alib{Module::Bootstrap}, an outer loop over all phases is initiated. An inner loop iterates
over all modules, in order of their "dependency level". For each combination of phase and
module, virtual method \alib{Module::bootstrap} is called. This assures that for each phase,
"low level modules" are initialized first and those of "higher level" are initialized next.

The three phases are defined as follows:

1. \aworx{lib::Module,BootstrapPhases::PrepareResources}<br>
   All initialization actions that exclusively involve static data, is deemed to be performed
   in this phase. For example, the \alib{boxing,BootstrapRegister,registration} of
   \ref alib_boxing_functions "box-functions" is to be done in this phase.

   The phase received its name from the fact that the  \alib{resources,ResourcePool} is already
   available and a module is supposed to to feed its static default resource strings to the instance
   retrieved with \alib{Module::GetResourcePool}.

   More on this topic will be explained in a later chapter.<br>


2. \aworx{lib::Module,BootstrapPhases::PrepareConfig}<br>
   In this phase, the configuration object is available and receivable with \alib{Module::GetConfig}.
   It may now be extended with plug-ins, but <b>access to configuration variables is not allowed yet!</b> <br>
   For most modules there is not much to do in this phase.<br>
   One important action usually placed here is to initialize static
   \ref alib_enums_records "ALib Enum Records". If - as it is recommended -
   \ref alib_enums_records_resourced "record definitions are given using externalized strings",
   then this is definitely the right place to invoke \alib{enums,EnumRecords::Bootstrap} for each
   enumeration in question.
   \note
     While the enumeration records are static data and could also be initialized in the first
     phase, after the definition of resources, placing it in this phase allows modules of higher
     dependency levels to modify (patch!) the resources of a lower level module  - prior to their use.

   <br>

3. \aworx{lib::Module,BootstrapPhases::Final}<br>
   In this phase, final initialization steps may be performed.<br>
   Only in this phase the <b>start of threads is allowed (!)</b>, as any mandatory \alib initializations which
   are not protected against racing conditions are deemed to be performed in the previous phases.<br>
   Furthermore, access to configuration variables is allowed in this phase.


\I{################################################################################################}
#### 3.2.2.2 Shutdown Phases #### {#alib_manual_bootstrapping_class_module_bootstrapping_sd}

With \alib{Module::Shutdown}, an outer loop over the two shutdown phases is initiated.
Again, an inner loop iterates over all modules, but this time in \b reverse order of their
"dependency level". For each combination of phase and module, virtual method \alib{Module::shutdown}
is called. This assures that for each phase, "high level modules" are shut down first and those of
"lower level" are shutdown later.

The two phases are defined as follows:

1. \aworx{lib::Module,ShutdownPhases::Announce}<br>
   Within this phase, a module can rely on the full stability of a software and all modules.
   Only actions might be taken that do not result in defects if features of a module are still
   used. Typical samples of actions to perform with this phase are writing out configuration data or
   making an application's state  persistent, to be able to restore it with a next run of a
   software.
   <br><br>

2. \aworx{lib::Module,ShutdownPhases::Destruct}<br>
   This is the "true" shutdown phase. After the phase a module is obligated to have freed all
   it's resources and is allowed to be dysfunctional afterwards.



\I{################################################################################################}
## 3.3 Class ALibDistribution ## {#alib_manual_bootstrapping_class_alibdistribution}

For default bootstrapping and shutdown, this is almost all we need to know. The remaining question is:
Where is the list of modules (used for the inner loops of \b Bootstrap and \b Shutdown) defined
and what exactly does "higher and lower level" module mean?
The latter was answered already in chapter \ref alib_manual_modules_dependencies_mandatory.
Looking at the graph presented in this chapter, lower level modules are \b Text and
\b Results, while higher level modules are for example \b Expressions, \b ALox or \b CLI.

Besides this schematic, the list depends on the availability of the modules, which is defined by
the \alibdist and it's permutation of selected modules.

Class \alib{ALibDistribution}, which is itself derived from class \alib{Module}, provides the
the list with its field \alib{ALibDistribution,Modules}.
Method \alib{ALibDistribution,BootstrapFillDefaultModuleList} fills the list in the right order,
respecting the dependency hierarchy and permutation of modules of the \alibdist_nl.

Now, if method \b Module::Bootstrap is invoked without filling the list
(as shown in the introductory section of this chapter), then the method will detect this and will
use \b BootstrapFillDefaultModuleList to do this now.

In later sections of this manual, options for modifying these defaults will be demonstrated.


\I{################################################################################################}
## 3.4 Standard Bootstrapping ## {#alib_manual_bootstrapping_standard}
With the knowledge taken from the previous sections, it is now easily understood what was said
in the introductory chapter:
\par
    <em>Standard bootstrapping of \alib is performed by invoking method \alib{Module::Bootstrap}
    on the singleton instance \ref aworx::ALIB of class \alib{ALibDistribution}.</em>

Consequently the simple version of bootstrapping was given like this:

        int main( int argc, const char **argv )
        {
            aworx::ALIB.Bootstrap(argc, argv);
            ...
            ...


This standard invocation of method \alib{Module::Bootstrap} defaults method argument \p{targetPhase} to
\alib{Module,BootstrapPhases::Final}. The loop iterating the phases, starts with the first phase
that the module has \b not been bootstrapped with, yet, and ends with the given \p{targetPhase}.
With that, all phases are executed in above sample.


What was not discussed, yet is when the instances of \alib{resources,ResourcePool} and \alib{config,Configuration}
are created and how the corresponding pointer members \alib{Module::resourcePool} and \alib{Module::config}
are set. This is how this is done:

- An instance of class \alib{resources,ResourcePool} is created prior executing the first
  phase \alib{Module::BootstrapPhases,PrepareResources} and is distributed amoung the modules.<br>
  The distribution is performed in reverse order, starting with the module that \b Bootstrap was
  invoked on (usually #aworx::ALIB) and from there to the lower level modules.

- The same is done with a new instance of class \alib{config,Configuration}, but prior to
  executing second phase \alib{Module::BootstrapPhases,PrepareConfig}.


The following schematic summarizes this:

  - Outer loop: Phase PrepareResources
    - Creation of a resource pool.
    - 1st inner loop: Distribution to lower level modules in reverse, descending order.
    - 2nd inner loop: Invocation of <em>bootstrap( PrepareResources )</em> on all dependent modules, in ascending order.
  - Outer loop: Phase PrepareConfig
    - Creation of configuration instance.
    - 1st inner loop: Distribution to lower level modules in reverse, descending order.
    - 2nd inner loop: Invocation of <em>bootstrap( PrepareConfig )</em> on all dependent modules, in ascending order.
  - Outer loop: Phase Final
    - Invocation of <em>bootstrap( Final )</em> on all dependent, in ascending order.

With this information the standard process of bootstrapping is well defined. The following
chapters introduce different ways to customize bootstrapping.

\I{################################################################################################}
## 3.5 Customizing The Bootstrap Process ## {#alib_manual_bootstrapping_customize}

\I{################################################################################################}
### 3.5.1 Using Custom Resources and/or Configuration Plug-ins ### {#alib_manual_bootstrapping_customize_resconf}

The default implementation of class \alib{resources,ResourcePool} used with non-customized
bootstrapping is of type  \alib{resources,LocalResourcePool} and this does \b not externalize
the resource strings. To use either alternative, built-in type \alib{resources,ConfigResourcePool}
or a custom implementation of the interface that attaches to a 3rd-party "resource pool backend",
all that needs to be done is to create such instance and pass it to method
\alib{Module,BootstrapSetResourcePool}.<br>
This has to be done \b prior to the first invocation of \alib{Module,Bootstrap}.

As documented with class \alib{config,Configuration}, the type allows to be equipped with custom
mechanics for loading external data. To do so, the bootstrapping process has to be interrupted
after the configuration is internally created. This is done by explicitly specifying
\alib{Module,BootstrapPhases::PrepareConfig} with method \b Bootstrap.

Now, the configuration can be accessed with \alib{Module::GetConfig} and
is manipulated as wanted. When done, bootstrapping is finalized by invoking \b Bootstrap a
second time with argument \alib{Module,BootstrapPhases::Final}.

The schematic that shows both approaches at once, then looks as follows:
- Create instance \b myResources
- Invoke \b BootstrapSetResourcePool(myResources)
- Invoke \b Bootstrap(PrepareConfig)
- Modify configuration object received with \b GetConfig.
- Invoke \b Bootstrap(Final)


\I{################################################################################################}
### 3.5.2 Bootstrapping Custom Modules ### {#alib_manual_bootstrapping_custommods}
As explained in previous chapter \ref alib_manual_bootstrapping_cpp, the reason why bootstrapping
\alib is a non-trivial task, does not lie in specifics of this library, but in a general lack of
support for bootstrapping in the C++ language. Any more complex software needs to solve this
task.

Consequently, it might be a reasonable decision, to adopt what this library offers and use the this
concept and the mechanics to bootstrap custom code units likewise.

Doing this is rather simple. The steps are:
1. Create a custom type derived from class \alib{Module} along with a global singleton instance of
   this type.
2. In the <c>main()</c> function, invoke \alib{ALibDistribution::BootstrapFillDefaultModuleList}
   on singleton #aworx::ALIB
3. Next, use method \alib{monomem,List::PushBack} to add the static instance of the custom
   module type(s) to field \alib{ALibDistribution::Modules} of singleton #aworx::ALIB.
4. Perform bootstrapping by invoking method \alib{Module::Bootstrap} on your custom module singleton
   instance.

\note A source code sample is given with the \ref alib_cli_tut "tutorial of ALib module CLI".

In more complex scenarios, a software can also create more than one module.
Each module may be appended to the module list (see step 3). If these modules are following a
dependency hierarchie, then the lowest (most independent) modules should be attached first.
The start of the bootstrapping (step 4) has to be performed on the latest module added.

\note  This rule is for the simple cases. More complex bootstrap strategies would incorporate
       the invocation of method \alib{Module::Bootstrap} on lower level modules first and
       later on higher level modules separately.


When a software chooses to hook itself into the bootstrap mechanism of \alib as shown above,
the resources and configuration data (including for example INI-files) would be shared
and contain both, data of \alib and custom data.<br>

Often, this is not a desired scenario, because:
- A software does not want to bother an end-user with the rather technical resources and
  configuration variables provided by \alib. Cluttering custom data with \alib data should be avoided
- A software might want to disallow an end-user to modify configuration data and/or resources
  of \alib.
- etc.

How these goals can be reached is explained in the next section.

\I{################################################################################################}
### 3.5.3 Using Multiple Resources and/or Configuration Instances ### {#alib_manual_bootstrapping_customize_non_shared}

With the bootstrap process described so far, one instance of a resource pool and
one instance of class \b Configuration is shared with all modules.

Sometimes, especially if custom modules become integrated into the bootstrap process of \alib,
it is wanted that different sets of modules share different instances of these objects, to
separate the data and maybe even to use different types of resource pools and configuration plug-ins.

To do so,  methods
- \alib{Module,BootstrapSetResourcePool} and/or
- \alib{Module,BootstrapSetConfig}

may be called on arbitrary modules, \b prior to starting bootstrapping.

An object set this way will not be overwritten when the corresponding bootstrap phase distributes
instances from higher- to lower-level modules. Moreover, if the algorithm finds an object already
set, then the distribution loop continues with this object!

This allows a rather natural way to separate all modules into logical sets that share one
resource pool and/or configuration.

In the case that all built-in \alib modules should use one instance and all custom modules
a different one, then the setter methods above have to be invoked simply on singleton #aworx::ALIB.

\I{################################################################################################}
### 3.5.4 Separating Bootstrap Phases ### {#alib_manual_bootstrapping_customize_separated}
The fact that method \alib{Module::Bootstrap} is allowed to be called directly on lower level modules
(those that are not the last of list \alib{ALibDistribution::Modules}), allows to to bootstrap
lower-level modules separated from bootstrapping corresponding higher-level ones.


Like in previous section, such approach might be needed in case that custom modules are integrated
into the \alib bootstrap process.

Let's consider the following sample:
1. Custom module \b MyApp is  derived from class \alib{Module}
2. In the <c>main()</c> function, \alib{ALibDistribution::BootstrapFillDefaultModuleList} is invoked
   on singleton #aworx::ALIB
3. The singleton of \b MyApp is added to the end of list \alib{ALibDistribution::Module}
4. Bootstrapping is fully performed on singleton #aworx::ALIB.
5. Bootstrapping is fully performed on singleton \b MyApp

The consequences from this approach are:
- Like in the previous chapter, the set of \alib modules share a different resource pool and
  configuration object than \b MyApp.
- During the bootstrapping of \b MyApp, built-in \alib modules fully bootstrapped and functional.

Of course, this approach can be mixed with the other variants of customization discussed in previous
sections.



\I{################################################################################################}
### 3.5.5 Customization Of Shutdown ### {#alib_manual_bootstrapping_custom_shutdown}
Customization of shutting down \alib should be a seldom need and works the same in principle.
Method \alib{Module::Shutdown} has defaulted parameter \p{targetPhase} and if specified to
\alib{Module::ShutdownPhases,Announce} then only the first phase is performed and custom
actions might be taken prior to invoking phase \alib{Module::ShutdownPhases,Destruct}.


\I{################################################################################################}
## 3.6 Bootstrapping Small Modules ## {#alib_manual_bootstrapping_smallmods}
As already explained, an \alibmod_nl is called a "full module", if it disposes on a strict
singleton type derived from class \alib{Module}.<br>
This is not the case for the light-blue colored modules shown in the
\ref alib_manual_modules_dependency_graph "module dependency graph".
Three of those still have the small rectangular markers that indicate that a module has to be
initialized and terminated.

The modules in question are:
- \alib_threads,
- \alib_boxing and
- \alib_time.

Each module provides namespace functions \b %Bootstrap and \b %Shutdown for that.

When the \alibdist includes also "full" modules,  initialization and termination of these three
"small" modules is performed with the corresponding action invoked on dependent "full" modules.
Therefore, in this case no custom invocations are needed.

However, should an \alibdist be used that is really limited to one or more of the "small" modules,
a user of the library has to make sure that the namespace functions are invoked on bootstrapping
and termination of the process.

\I{################################################################################################}
## 3.7 Assuring Compilation Compatibility ## {#alib_manual_bootstrapping_assertcomp}

It is important to understand that an \alib library compiled with a certain set of options
might be incompatible to compilation units that use a different set of options. For example, the
footprint (size) of library types might be different.

If incompatible compilation units are mixed, often no warning is issued (neither by
the compiler nor the linker) and the execution of a process might lead to very strange behavior
which is irritating and hardly to debug.

To detect incompatible compilation settings, method \alib{ALibDistribution::CheckDistribution} should be invoked
on singleton \alib{ALibDistribution} from custom bootstrap code of each custom compilation target that uses
\alib. Code for doing so looks like this:


        int main( int argc, const char **argv )
        {
            aworx::ALIB.Bootstrap(argc, argv);
            aworx::ALIB.CheckDistribution();
            ...


The trick here is, that the method parameters are defaulted with macros that contain compilation
information. The method compares this information to that given at the time of library compilation
from the same macros.

\note
   With \e CMake builds, if \e CMake function \ref alib_manual_build_cmake_5 "ALibSetCompilerAndLinker"
   is used with a custom target, all settings are guaranteed to be compatible.

<p>
\note
   Internally method \alib{ALibDistribution::CheckDistribution} uses method
   \alib{Module::VerifyCompilationFlags} which allows a "per module" verification.
   This inner method may be used for custom distributions (compilations) and/or custom modules,
   but is not further explained in this manual.


\I{################################################################################################}
\I{##########  4.  Build                                                                           }
\I{################################################################################################}

# 4. Building The Library # {#alib_manual_build}

\I{################################################################################################}
## 4.1 Overview ## {#alib_manual_build_overview}

\I{################################################################################################}
### 4.1.1 Platforms and Toolchains ### {#alib_manual_build_overview_platforms}

As of today, <b>%ALib for C++</b> is compiled and tested under the following platforms and
toolchain combinations:
- GNU/Linux Arch 6.6.6, GNU C++ 13.2.1 / Clang++ 16.0.6, C++ 11 - 20, 32-Bit / 64-Bit<br>
  (This is the main development platform.)
- Windows 10/11, MSC 17.8.3 (Visual Studio 2022), , C++ 11 - 20, 32-Bit / 64-Bit
- Windows 10/11, MinGW 11.0,  C++ 11 - 17, 64-Bit ( <c>C++ 20 does  not compile! with current MinGW!</c>)
- MacOS 13, Intel i9, AppleClang 14.0.3, C++ 11 - 20 C++, 64-Bit
- MacOS 13, Apple M1/ARM64, C++ 11-20, 64-Bit
- Raspberry 3, ARM, 64-bit OS, GCC 10.2.1, C++ 11 - 20, 64-Bit
- Raspberry 4, ARM, 32-bit OS, GNU C++ 12.2.0, C++11-20
- Raspberry 4, ARM, 64-bit OS, GNU C++ 12.2.0, C++11-20

All development was performed in a) CLion/CMake (all platforms) and b) Visual Studio Community
Edition 2022. All necessary IDE files are included in the repository.

Adoptions to other platforms, toolchains and IDEs should be implementable with limited efforts.
All relevant code which selects platform/toolchain specific libraries, intrinsics, etc., will
expose a preprocessor error if a section fails due to an unknown environment.
This allows to quickly insert the right platform/toolchain specific code at these places.

\note We would be very happy to receive your feedback/input on necessary changes for other
      platforms!

Especially errors occurring in header \alibheader{lib/integers.hpp} might be quite likely for unknown
platform / toolchain combinations. Here, a set of five compiler symbols might be passed using
the build system (e.g. CMake), which are documented with symbol \ref ALIB_SIZEOF_INTEGER.

<b>The C++ compiler warning level is defaulted to the bearable maximum.</b> This means, that the
inclusion of \alib headers into a custom project's compilation process should never lead to
compilation warnings or errors when similar high custom warning levels (of the including project)
are used.


\I{################################################################################################}
### 4.1.2 Reference Toolchain CMake ### {#alib_manual_build_overview_cmake}

While project files for different IDEs might be provided with the codebase, the main development of \alib is
performed using \https{CMake,cmake.org/} scripts.
Also, the relationship of source file and \alibmod_nl selection is <b>"officially defined"</b>
by CMake scripts.

\par
  <b>The \e CMake scripts included in the \alib distributions are to be seen as the
  reference guideline to building \alib. The scripts may even be more precise (and up-to-date!)
  than the documentation you currently read itself.</b>


Even for non-experienced users (in respect to CMake), the syntax of the file should be easily understood.
So, do not hesitate to open and read the CMake files for your project setup reference.

A Microsoft Visual Studio solution and according project files which build an \alib DLL and the
unit tests, are included in the \alib distribution.
These may be used to compile an \alib library that includes all of \alib, which can be used
for own projects.<br>
Limited library projects that include only a selection of modules of \alib are not provided
and thus have to be created if they are desired.


\I{################################################################################################}
### 4.1.3 Library Installation ### {#alib_manual_build_overview_noinstall}
As of today, no installation process of a shared library version of \alib is available with
the build process defined. Not installing a library has of-course the disadvantage, that every
software project needs to compile its own version of it, and the library is by default not shared between
applications, even if compiled as a "shared library", respectively DLL.

While this may change in the future, the advantage of this approach is that an application has
a lot flexibility in respect to compiling \alib using the exact set of features it desires.

Therefore, to enable a software to use \alib, the sources of the library have to become a part
of the build process in any form. As usual, there are three possible basic options:
1. Compiling \alib to a static library,
2. compiling \alib to a shared library or
3. compiling \alib sources directly into another software entity.

When this manual section talks about "building the ALib library", one of the three options is meant.
Of-course, a custom "installation" process can be used to place library binary and header
files in corresponding system folders.


\I{################################################################################################}
### 4.1.4 Unit Tests ### {#alib_manual_build_overview_unittests}
An extensive set of unit tests is included in the distribution.


\I{################################################################################################}
## 4.2 Performing A Test Compilation  ## {#alib_manual_build_test}
Clone the \alib repository from \https{ALib at GitHub,github.com/AlexWorx/ALib-Class-Library}
to a place where you commonly store 3rd party libraries that your projects are using.
Alternatively, download and unpack the ZIP file to that same place.

In this documentation, we will refer to this library location as the <b><em>ALIB_BASE_DIR</em></b>.
After a fresh installation, it should contain at least the following subfolders:

        ALIB_BASE_DIR/build
        ALIB_BASE_DIR/docs
        ALIB_BASE_DIR/html
        ALIB_BASE_DIR/src
        ALIB_BASE_DIR/tools


To build the unit tests, perform the following steps:

- open a console window and cd into directory:

        ALIB_BASE_DIR/build/cmake/unittests

- create two sub-directories from here, one named *debug* and the other *release*
- cd into directory *debug* and type

        cmake ..

- once \e CMake has run, type

        make -j

The compiled sample executable should have been created and you can start it with

    ./ALib_UT

Within a few seconds all unit tests should have been performed.

For a <b>release build</b>, the steps are similar.
After you cd into the 'release' folder, the cmake command is:

    cmake -DCMAKE_BUILD_TYPE=Release ..

\note
  For the unit tests, \e Google \e gtest gets downloaded (once) and incorporated
  as a source project within the binary folder. This means:
   - This library does not need to be installed anywhere else on the system
   - This library gets deleted when deleting the CMake build folder
     (in the sample above named "debug" respectively "release").


\I{################################################################################################}
## 4.3 A Step-By-Step CMake Sample ##  {#alib_manual_build_sample}

With using \e CMake, compiling and using \alib  is very straight forward.
This is because a set of easy to use \e CMake scripts is provided, of which one is to be included
into the custom  \e CMake script.

The following demonstrates this step by step along the sample project found in folder

        ALIB_BASE_DIR/src/samples/alox

<br>
<b>Step 1: Creating the CMake file</b><br>
A custom \e CMake file has to be created. To start with, the top of the file might look like this:

 \snippet "../../build/cmake/samples/ALox/CMakeLists.txt"        DOXYGEN_CMAKE_INCLUDE_1

<br>
<b>Step 2: Choose %ALib Modules</b><br>
The list of \alib modules to be included in the built is defined with \e CMake list variable
\c ALIB_DISTRIBUTION which has to be set prior to invoking the \alib \e CMake script.
If the list is left empty, it will be defaulted to \b "ALL", which chooses all \alib modules
available.<br>
In our sample, we add \b "ALOX", which chooses module \alib_alox and all
\ref alib_manual_modules_dependency_graph "dependent modules".


 \snippet "../../build/cmake/samples/ALox/CMakeLists.txt"        DOXYGEN_CMAKE_INCLUDE_2


<br>
<b>Step 3: Set Other Feature Variables</b><br>
Our project should be compiled using C++ 11. This is set with:

 \snippet "../../build/cmake/samples/ALox/CMakeLists.txt"        DOXYGEN_CMAKE_INCLUDE_3


<br>
<b>Step 4: Include "ALib.cmake" </b><br>
Now we are ready to include the main \alib \e CMake script:

 \snippet "../../build/cmake/samples/ALox/CMakeLists.txt"        DOXYGEN_CMAKE_INCLUDE_4

Note that this sample is using a relative path. In a real-world sample, the path might as well
be an absolute one.
After the script is run, some global \e CMake variables and functions are defined.
All of those are documented in the next chapter. Let us first continue the sample:

<br>
<b>Step 5: Define A Library Project </b><br>
We invoke \e CMake function \c ALibAddSharedLibrary, which creates a \e CMake target called
\c "ALib_SharedLib" having all necessary settings:

 \snippet "../../build/cmake/samples/ALox/CMakeLists.txt"        DOXYGEN_CMAKE_INCLUDE_5

<br>
<b>Step 6: Define The Custom Project </b><br>
Now we are good to define our custom project in a usual way:

 \snippet "../../build/cmake/samples/ALox/CMakeLists.txt"        DOXYGEN_CMAKE_INCLUDE_6

<br>
<b>Step 7: Add Compiler And Linker Settings</b><br>
Our main project needs to share some \alib compiler and linker settings with the \alib
library project. To achieve this we invoke \e CMake function <c>ALibSetCompilerAndLinker</c>:

 \snippet "../../build/cmake/samples/ALox/CMakeLists.txt"        DOXYGEN_CMAKE_INCLUDE_7

<br>
<b>Step 8: Add Library Project To Custom Project</b><br>
The final step is to add the library project to the custom sample project, which is again a
standard \e CMake task:

 \snippet "../../build/cmake/samples/ALox/CMakeLists.txt"        DOXYGEN_CMAKE_INCLUDE_8


That's it. With this simple CMake file we have created a tailored \alibdist library
and have linked it to our sample project, which is now ready to be built!


\I{################################################################################################}
# 4.4 The Build Process In Detail#  {#alib_manual_build_cmake}

The previous chapter demonstrated the use of the \e CMake script \c ALib.cmake provided with
\alib. In the following sections a reference documentation on all aspects of the script is
given.

Along these lines, the build requirements of \alib is explained - also for users of any other build
system. Independent from the build-system used, the following information has to be collected and
accordingly set:

- The set of \alib source files that comprise the desired set of \alibmods.
- C++ Version 11 or higher (to be set with the compiler).
- Compilation symbols that select the \alibmods have to be passed to the compiler.
- Compilation symbols that choose \alib features have to be passed to the compiler.
- External library dependencies have to be determined.
- Linker flags have to be defined.

\note
  The complete set of symbols that the \alib library accepts from the compiler (usually \e -D option)
  are \ref GrpALibPreproSymbols "documented here".


\I{################################################################################################}
## 4.4.1  Selecting ALib Modules ##  {#alib_manual_build_cmake_1}
\e CMake list variable \c ALIB_DISTRIBUTION is an input/output list which defines the particular
\alibmods that should be included in the built.
The script will process the values given and will extend the list to include all necessary modules that
the \ref alib_manual_modules_dependency_graph "given selection depends on".

The values correspond to the \ref alib_manual_modules_overview "module names" in upper case letters,
hence \b ALOX, \b BOXING, \b CHARACTERS, etc...

If the variable is not set or contains special name \b "ALL", all modules are chosen to be built
and included.

\I{################################################################################################}
### 4.4.2  Variables For Directory and Source Code Definitions ###  {#alib_manual_build_cmake_2}
The following \e CMake variables are available after the invocation of the script:
- \c ALIB_BASE_DIR<br>
  Defines the directory where the \alib project is stored.<br>
  This variable may also be specified prior to entering the script to specify a different directory
  than the default, which is inferred from the full path name of the script invoked.
<p>

- \c ALIB_SOURCE_DIR<br>
  Defines the directory where the \alib source files are stored. The header files are located
  in the same directories.<br>
  This variable may also be specified prior to entering the script to specify a different directory
  than the default, which is

            ${ALIB_BASE_DIR}/src
<p>

- \c ALIB_SOURCE_FILES<br>
  The list of source files (compilation units) needed to compile \alib.
<p>

- \c ALIB_INCLUDE_FILES<br>
  The list of header files needed to compile \alib.


\I{################################################################################################}
### 4.4.3  Cached CMake Variables ###  {#alib_manual_build_cmake_3}
The script will create a set of cached boolean \e CMake variables (which are variables that can be
edited with CMake GUI tools and various C++ IDEs).

The following variables correspond directly to \ref GrpALibPreproSymbols "preprocessor symbols"
used for code selection and thus this list links to their corresponding documentation:

- \ref ALIB_AVOID_ANALYZER_WARNINGS
- \ref ALIB_CHARACTERS_WIDE
- \ref ALIB_CHARACTERS_SIZEOF_WCHAR
- \ref ALIB_DEBUG
- \ref ALIB_DEBUG_BOXING
- \ref ALIB_DEBUG_MONOMEM
- \ref ALIB_DEBUG_ARRAY_COMPRESSION
- \ref ALIB_DEBUG_RESOURCES
- \ref ALIB_DEBUG_STRINGS
- \ref ALIB_EXT_LIB_THREADS_AVAILABLE
- \ref ALIB_FEAT_BOOST_REGEX
- \ref ALIB_FEAT_BOXING_BIJECTIVE_CHARACTERS
- \ref ALIB_FEAT_BOXING_BIJECTIVE_FLOATS
- \ref ALIB_FEAT_BOXING_BIJECTIVE_INTEGRALS
- \ref ALIB_FEAT_SINGLETON_MAPPED
- \ref ALIB_GDB_PP_FIND_POINTER_TYPES
- \ref ALIB_GDB_PP_SUPPRESS_CHILDREN
- \ref ALIB_PRECOMPILED_HEADER
- \ref ALIB_RESOURCES_OMIT_DEFAULTS
- \ref ALOX_DBG_LOG
- \ref ALOX_DBG_LOG_CI
- \ref ALOX_REL_LOG
- \ref ALOX_REL_LOG_CI

In addition, the following further cached variables are set:
- <b>ALIB_CMAKE_COTIRE</b><br>
  Defines if \ref alib_manual_build_more_cotire "Cotire" is to be used for the built.
<p>

- <b>ALIB_VERSION</b><br>
  Defines the \alib library version. This variable can not be changed, respectively will be
  overwritten on \e CMake generation. It is specified as a cached \e CMake variable just for the
  reason of presenting the \alib version to tools that allow to modify \e CMake settings.

  Furthermore, non-cached version variables \c ALIB_VERSION_NO and \c ALIB_VERSION_REV are
  set which hold the version number and revision number as separate integral values.

- <b>ALIB_CMAKE_VERBOSE</b><br>
  If set to \c true, extended information will be printed with running the \e CMake script.
  See \ref alib_manual_build_more_otherbuildsystems for details.

- <b>ALIB_CMAKE_SKIP_THREAD_LIB_SEARCH</b><br>
  If set to \c true, the provided script will not search for a thread library on the target
  platform. For more information see chapter \ref alib_manual_modules_impact_singlethreaded.

- <b>ALIB_DEBUG_GLIB</b><br>
  If \c true, symbols \b _GLIBCXX_DEBUG", \b _GLIBCXX_DEBUG_PEDANTIC and
  \b _GLIBCPP_CONCEPT_CHECKS are passed to the compiler.

- <b>ALIB_COVERAGE_COMPILE</b><br>
  If \c true, option <b>--coverage</b> is added to CMake variables \b ALIB_COMPILER_OPTIONS and
  \b ALIB_LINKER_OPTIONS



\I{################################################################################################}
### 4.4.4  CMake Build-Setting Variables ###  {#alib_manual_build_cmake_4}
The script will create the following non-cached \e CMake variables, which can be used to define
build-settings of custom projects:

- <b>ALIB_SYMBOLS</b><br>
  Will contain the \ref GrpALibPreproSymbols "ALib preprocessor symbols", as defined by the cached variables.
  This variable can for example be used as a parameter to \e CMake function \c target_compile_definitions().
<p>

- <b>ALIB_COMPILER_WARNINGS</b><br>
  Will contain compiler parameters to set the (high!) warning level used with compiling \alib.
  This variable can for example be used as a parameter to \e CMake function
  \c target_compile_options().<br>
  Custom entries may be added to the list prior to invoking \b ALib.cmake.
  If entry <em>"ALIB_SUPPRESS_COMPILER_WARNINGS"</em> is found, that entry is removed and no
  compiler-specific warning settings are added to this symbol.
<p>

- <b>ALIB_COMPILER_OPTIONS</b><br>
  Will contain parameters to be passed to the compiler when linking \alib.
  This variable can for example be used as a parameter to \e CMake function
  \c target_compile_options().
<p>

- <b>ALIB_LINKER_OPTIONS</b><br>
  Will contain parameters to be passed to the linker when linking \alib.
  This variable can for example be used as a parameter to \e CMake function
  \c set_target_properties().
<p>

- <b>ALIB_EXTERNAL_LIBS</b><br>
  Will contain a list of external libraries needed to build \alib.
  This variable can for example be used as a parameter to \e CMake function
  \c target_link_libraries().

In addition, the following non-cached variable is an input variable which may be set prior to
invoking the script:

- <b>ALIB_COMPILER_FEATURES</b><br>
  May contain \e CMake feature parameters to be passed to the compiler.
  This variable can for example be used as a parameter to \e CMake function \c target_compile_features().

\I{################################################################################################}
### 4.4.5  CMake Functions Defined By The Script ###  {#alib_manual_build_cmake_5}
The script will define the following \e CMake functions:

- <b>ALibAddStaticLibrary</b><br>
  This parameterless function creates a static library target called \c ALib_StaticLib.
<p>

- <b>ALibAddSharedLibrary</b><br>
  This parameterless function creates a shared library (under Windows OS a DLL) target called
  \c ALib_SharedLib.
<p>

- <b>ALibSetCompilerAndLinker( target )</b><br>
  This function applies the settings of all variables listed in the previous section to the given
  \p{target}. In addition, the \e target's CMake property \c POSITION_INDEPENDENT_CODE is switched
  on.

\I{################################################################################################}
### 4.4.6  Library Filename ###  {#alib_manual_build_cmake_6}
The library's filename is determined by (non-cached) \e CMake variable \c ALIB_LIBRARY_FILENAME.
If this variable is \b not set prior to invoking script <c>ALib.cmake</c>, then the name is
determined automatically from the selected modules.

The name is used with functions \c ALibAddStaticLibrary and \c ALibAddSharedLibrary, introduced
in the previous section.

If not provided, the name will be assembled according to the following set of rules:

- The name starts with \c "alib_".
- The library version is appended, for example \c "2312R0".
- In the case of debug builds, term \c "_DBG" is appended.
- In the case that all modules are selected in the \alibdist, no further rule is applied.

- Otherwise, each selected module's name is added in capital letters, separated by an underscore
  character (<c>'_'</c>) unless a module is not "superseded" by another module that has a
  \ref alib_manual_modules_dependency_graph "mandatory dependency" to it.

- As an exclamation, in the case that module \alib_strings is included (and no other module
  supersedes it) and furthermore in the case that \ref ALIB_DEBUG_STRINGS is set,
  suffix <c>"_DBGSTRINGS"</c> is appended instead of <c>"_STRINGS"</c> .

- In the case that \alib_alox is included, the suffixes <c>_ALOX</c> is extended by
  suffix <c>NRL</c> if release logging is switched off. In addition, suffix <c>NDL</c> is added with
  debug builds that do not include debug logging. Note that both exclamations cover the
  non-default, unusual compilation cases in respect to the availability of debug- and release logging.


\I{################################################################################################}
## 4.5 More Information ##  {#alib_manual_build_more}

### 4.5.1 Other Build Systems ### {#alib_manual_build_more_otherbuildsystems}

As already explained, the \e CMake build process is viewed to be the reference process for \alib
compilation.

For none\e CMake users, the selection of the exact minimum set of source and header files,
is probably the most difficult (and annoying) task.
In \e CMake we have separated the source selection into script:

            ALIB_BASE_DIR/build/cmake/ALibSources.cmake

which is invoked by the main script.

This script might be analysed to identify the source and header file dependencies of the
different \alibmods.

Likewise, script

            ALIB_BASE_DIR/build/cmake/ALibModules.cmake

might be analysed to get actual (and correct) information about module dependencies.


Furthermore, by setting CMake cache variable \b ALIB_CMAKE_VERBOSE to \c true, running \e CMake
will write extended information that might be used and copied into the configuration files
of other build systems or into IDE project files.

Among the data displayed is:
- List of modules included in the distribution.
  (Modules that the user \ref alib_manual_build_cmake_1 "explicitly selected" plus recursive dependencies)
- List of source and header files that are needed for the build.
- Resulting library filename.
- Base folder of source files.
- The compiler symbols (definitions) passed.
- The compiler warning flags.
- The compiler features and other flags.
- The linker flags
- External libraries used.


\I{################################################################################################}
### 4.5.2 Choosing C++ Language Version ### {#alib_manual_build_more_cppversion}

As demonstrated in the chapter \ref alib_manual_build_sample "A Step-By-Step CMake Sample" (Step 3),
\e CMake variable \c ALIB_COMPILER_FEATURES may be used to determine the C++ language standard for
\alib targets and optionally for custom targets (i.e. if function \c ALibSetCompilerAndLinker is
invoked for a custom target).

\alib requires C++ language level \c 11 as a minimum and is compatible with levels \c 14 and \c 17.
\alib might perform better with higher language levels.

\e CMake provides other (maybe even more preferable) mechanics to determine/set the C++ language
level, which of course may be used alternatively.

\I{################################################################################################}
### 4.5.3 Copying The Sources ### {#alib_manual_build_more_copysources}

If \e CMake variable \c ALIB_SOURCE_COPY_TARGET_DIR is set prior to invoking CMake script
\c %ALib.cmake, then the source code (compilation units and header files) are copied to the
directory specified in the variable. If the variable does not point to a valid directory, an
error is raised and the \e CMake script is stopped.

The files copied represent exactly the set of files which are needed for compiling the combination
of \alibmods, which are optionally specified with list variable \c ALIB_DISTRIBUTION
(see \ref alib_manual_build_cmake_1).

This feature therefore can be used to create a fresh, filtered copy of the \alib source tree
tailored to an application. Nevertheless, it is usually not recommended to do so, because
source files that are not used by a combination of modules are neither included as header files,
nor compiled. The feature is rather used by the \alib developers to verify module and source code
dependencies.

\I{################################################################################################}
### 4.5.4 External Library Dependencies ### {#alib_manual_build_more_externallibs}

ALib has <b>no mandatory</b> dependencies to external (3rd-party) libraries.
The following \b optional dependencies exist:

1. Boost RegEx<br>
   If enabled by compiler symbol \ref ALIB_FEAT_BOOST_REGEX, a dependency to
   \https{boost,www.boost.org} library component
   \https{regex,www.boost.org/doc/libs/1_68_0/libs/regex/doc/html/index.html} is made.
   As a result, the following \alib features become available:
   - In module \alib_strings, class \alib{strings::util,RegexMatcher}
   - In module \alib_expressions, with expression compiler plugin \alib{expressions::plugins,Strings},
     expression term \b RegExMatch.

2. Standard C++ library<br>
   Some support to make types of the C++ standard library compatible with various concepts of
   \alib is activated by including compatibility header files found in source folder
   \alibsrcdir{compatibility}.<br>
   For more information see the following namespace documentations:
   - #aworx::lib::characters::compatibility::std
   - #aworx::lib::strings::compatibility::std
   - #aworx::lib::boxing::compatibility::std

3. QT Library<br>
   If \alib is used in combination with the \https{QT Class Library,www.qt.io}, compatibility
   support for character array types (strings and character vectors) of the <em>QT Library</em>
   becomes available with modules \alib_boxing and \alib_strings.<br>
   Such support is activated simply by including compatibility header files found in source folder
   \alibsrcdir{compatibility}.<br>
   For more information see the following namespace documentations:
   - #aworx::lib::characters::compatibility::qt
   - #aworx::lib::boxing::compatibility::qt


\I{################################################################################################}
### 4.5.5 Using Cotire To Speed-Up Builds ### {#alib_manual_build_more_cotire}

\https{Cotire,github.com/sakra/cotire/} is an open source CMake script which modifies C++ CMake
targets in a way to speed up compilation. This is achieved using mainly two techniques: Precompiled
header files and so called "unity builds".

The provided CMake script \c %ALib.cmake defines CMake cache variable \c ALIB_CMAKE_COTIRE. If
this variable evaluates to  \c true, then the script downloads
\https{Cotire,github.com/sakra/cotire/} (once) and includes it.
In this case, script \c %ALox.cmake applies cotire to the library targets created with
\b ALibAddStaticLibrary and \b ALibAddSharedLibrary. To use cotire with custom targets, \e CMake
function \e ALibSetCotire is defined.

To benefit from the unity build option (which may cut build time quite dramatically!), you have two
options:
1. Setup your target to use project \c ALox_SharedLib_unity instead of \c ALox_SharedLib
   (respectively \c ALox_StaticLib_unity instead of \c ALox_StaticLib).
   This should be done depending on the setting of the CMake variable, as shown in the following
   sample:

   \snippet "../../tools/DoxygenGraphTemplateInstanceRemover/CMakeLists.txt"    DOXYGEN_CMAKE_COTIRE_TARGET

2. Use cotire for your project as well and then choose the new make target with suffix "_unity"
   for building. This target will automatically use the "_unity" target version of the \alox
   library as well.
   This second approach is used in the provided \b ALoxSample project and CMake file.

By default, \https{Cotire,github.com/sakra/cotire/} is switched off in the make files provided.
This is because it adds a next layer of complexity for compiling <b>%ALib/%ALox</b>.
But it is generally worth to have a try!




\I{################################################################################################}
\I{##########  Appendices                                                                      }
\I{################################################################################################}
# Appendices # {#alib_manual_appendix}

\I{################################################################################################}
## A.1 Naming Conventions ## {#alib_manual_appendix_naming}

The C++ language standard does not suggest naming rules. This is different to, for example,
the \c JAVA language. While some people could say, that the C++ standard library naming scheme
suggests such rules, others say that it is especially valuable, that code outside namespace
\c std differs from that - to be better distinguishable within source code.

\alib uses the following rules:
- Preprocessor symbols are "UPPER_SNAKE_CASE" and mostly are prefixed "ALIB_".
- Global variables are also UPPER_SNAKE_CASE.
- Otherwise, underscores (snake_case) are almost never used.
- Namespaces are in lower case letters consisting of single words (no camel casing).
- All other entity names are either lowerCamelCase or UpperCamelCase.
- Public namespace functions are UpperCamelCase.
- Hidden (e.g. anonymous) namespace functions are lowerCamelCase.
- Types on namespace scope are UpperCamelCase.
- Members and inner types are UpperCamelCase if public, otherwise lowerCamelCase.
- Types and members that are available only in debug-compilations, are prefixed \b "Dbg".
- Method and function parameters are lowerCamelCase.
- Templated types UpperCamelCase with a leading <b>'T'</b>, for example \b TString.
- Template parameters types are also UpperCamelCase with a leading <b>'T'</b>. Only in seldom cases, a
  template parameter is just named <b>"T"</b>. Usually the name should indicate what kind
  of templated type is expected or what is to be done with it.
- Template structs that might specialized by users of this library are UpperCamelCase with
  a (snake_case) prefix of <b>"T_"</b>. For example, \b T_Boxer or \b T_CharArray.
- Template structs that are \b not to be specialized by users (because they have been specialized
  sufficiently by \alib already) are UpperCamelCase with a prefix of <b>"TT_"</b>.
  This second 'T' could be considered indicating the word "tool", as usually these are tool structs
  that provide a certain information about a types. Examples are found with
  \aworx{lib,characters::TT_IsChar}, \aworx{lib,strings::TT_IsAppendable} or
  \aworx{lib,boxing::TT_IsCustomized}.

As a final remark, when browsing the code it could be noticed that a lot of block-formatting is used.
While a line width of 100 characters is usually not exceeded, for the sake of building code
blocks, sometimes this line width barrier is ignored. From our perspective, the usefulness of tabbed
code blocks is very much underestimated. Besides readability, a lot of annoying typos can
be detected easily, prior to a next build run.<br>
In addition, tabbed code blocks often largely improve the ability to quickly refactor a codebase
manually. It should be allowed to mention, that the editor of C++ IDE \b CLion here has some
unrivalled features: Instead of only supporting block selection and copy/paste of blocks, this
editor creates a set of completely new "carets" in the moment block selection starts.
We want to thank the team of [JetBrains](www.jetbrains.com) for supporting \alib development
by providing a free \https{Open Source License,www.jetbrains.com/buy/opensource/}
of their absolutely superb set of IDEs.



\I{################################################################################################}
## A.2 How To Use This Library ## {#alib_manual_appendix_howto}

Most of the time, a 3rd party library like \alib is used to help solving a certain task. Such
tasks are addressed with higher level modules, like \alib_alox, \alib_cli or \alib_expressions.
In this case, the corresponding module documentation should be read directly, without loosing time
on learning too much about the lower level modules and types.

If you find the lower level types useful for your own projects, those will be understood over
time and by reading the reference documentation of types found in their corresponding namespaces.

Should you really just be interested in general and therefore absolutely not knowing where to start
reading, we recommend to start with some of the module's programming manuals, for example
\alib_boxing or \alib_strings. As debug log-output is something most projects needs, another
recommendation might be the
\https{ALox Logging Library Tutorial,alexworx.github.io/ALoxLogging-Library/cpp_ref/alox_cpp_tutorial.html}.

The manuals mentioned above may provide you with a good grasp of the design principles and
features of \alib in general and thus with the value that \alib might bring to your own software
projects.

\warning
  Experienced C++ programmers might complain that the Programmer's Manuals are to lengthy.
  Together they comprise almost <b>500 pages</b>!<br>
  We could now  say that the reason for often being quite "verbose" is that the manual address
  less experienced programmers. But this is not the truth. Explaining the details just helps
  us to understand a module's goals better and leads to a better code design.
  It happens that manual sections are written \e before the corresponding library feature is
  even implemented. Or, that while writing a manual chapter, the already written code gets heavily
  refactored.<br>

\warning
  While we excuse for verbosity, we think that often, the
  \ref aworx::lib "reference documentation" of types and entities found in the library provide a
  good way to avoid reading the libraries manuals! :-)



*/
